# common
import pathlib
import random
import tkinter as tk
import unittest

# Epub2Cbz
from PIL import Image

from CoverManagerLib.cbz_handler import SetCover
from CoverManagerLib.models import cover_process_item_info
# Volume Manager
from MangaManager.VolumeManager import VolumeManager
from MetadataManagerLib import MetadataManager, models
from MetadataManagerLib.cbz_handler import *

# Manga Tagger
# Cover Manager
comicinfo_23 = """
<ComicInfo xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
   <!--Generated by Manga Tagger, an Endless Galaxy Studios project-->
   <Series>Maou ni Natta node, Dungeon Tsukutte Jingai Musume to Honobono suru</Series>
   <Number>23</Number>
   <Count>1</Count>
   <Summary/>
   <Year>2018</Year>
   <Month>5</Month>
   <Writer>Ryuuyuu</Writer>
   <Penciller>Note Toono</Penciller>
   <Inker>Note Toono</Inker>
   <Colorist>Note Toono</Colorist>
   <Letterer>Note Toono</Letterer>
   <CoverArtist>Note Toono</CoverArtist>
   <Publisher>Dra-Dra-Dragon Age</Publisher>
   <Genre>Fantasy</Genre>
   <Web>https://myanimelist.net/manga/115200/Maou_ni_Natta_node_Dungeon_Tsukutte_Jingai_Musume_to_Honobono_suru</Web>
   <LanguageISO>en</LanguageISO>
   <Manga>Yes</Manga>
   <Notes>Scraped metadata from AniList and MyAnimeList (using Jikan API) on 2021-12-24 12:38 PM EST</Notes>
</ComicInfo>
"""
comicinfo_24 = """
<ComicInfo xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
   <!--Generated by Manga Tagger, an Endless Galaxy Studios project-->
   <Series>Maou ni Natta node, Dungeon Tsukutte Jingai Musume to Honobono suru</Series>
   <Number>24</Number>
   <Count>1</Count>
   <Summary/>
   <Year>2018</Year>
   <Month>5</Month>
   <Writer>Ryuuyuu</Writer>
   <Penciller>Note Toono</Penciller>
   <Inker>Note Toono</Inker>
   <Colorist>Note Toono</Colorist>
   <Letterer>Note Toono</Letterer>
   <CoverArtist>Note Toono</CoverArtist>
   <Publisher>Dra-Dra-Dragon Age</Publisher>
   <Genre>Fantasy</Genre>
   <Web>https://myanimelist.net/manga/115200/Maou_ni_Natta_node_Dungeon_Tsukutte_Jingai_Musume_to_Honobono_suru</Web>
   <LanguageISO>en</LanguageISO>
   <Manga>Yes</Manga>
   <Notes>Scraped metadata from AniList and MyAnimeList (using Jikan API) on 2021-12-24 12:38 PM EST</Notes>
</ComicInfo>
"""

original_cleanup_var1 = ""
final_cleanup_var1 = ""


class ComicInfoClassTester(unittest.TestCase):
    """
    The purpose of this test is to check ComicInfo class is properly edited.
    ComicInfo is an automatically generated class with some change.
    """

    def setUp(self) -> None:
        self.comicinfo = ComicInfo.ComicInfo()
        self.comicinfo.set_AgeRating(ComicInfo.AgeRating.RATING_PENDING)

    def test_manualModifications(self):
        # @classmethod
        # def list(cls):
        #     return list(map(lambda c: c.value, cls))
        self.assertTrue(ComicInfo.AgeRating.list())
        self.assertTrue(ComicInfo.ComicPageType.list())
        ComicInfo.parseString(comicinfo_23, silence=True, print_warnings=False, doRecover=True)


class CoverManagerTester(unittest.TestCase):
    """
    This test checks the functionality of coverManager and makes sure that the content of the files do not get wiped
    """

    def setUp(self) -> None:
        self.test_files_names = []  # Simulated list of filepaths
        print("\n", self._testMethodName)
        print("Setup:")
        image = Image.new('RGB', size=(20, 20), color=(255, 73, 95))
        image.format = "JPEG"
        imgByteArr = io.BytesIO()
        image.save(imgByteArr, format=image.format)
        imgByteArr = imgByteArr.getvalue()
        for ai in range(3):  # Create 3 archives.cbz
            out_tmp_zipname = f"Test_{ai}_{random.randint(1, 6000)}.cbz"
            self.test_files_names.append(os.path.abspath(out_tmp_zipname))
            self.temp_folder = tempfile.mkdtemp()
            print(f"     Creating: {out_tmp_zipname}")  # , self._testMethodName)
            with zipfile.ZipFile(out_tmp_zipname, "w") as zf:
                for i in range(1, 6):
                    zf.writestr(f"{str(i).zfill(3)}.jpg", imgByteArr)
        image.save("Test_4_sample_cover.jpg", format=image.format)
        self.test_files_names.append(os.path.abspath("Test_4_sample_cover.jpg"))
        self.sample_cover = os.path.abspath("Test_4_sample_cover.jpg")
        self.initial_dir_count = len(os.listdir(os.getcwd()))

    def tearDown(self) -> None:
        print("Teardown:")
        for filename in self.test_files_names:
            print(f"     Deleting: {filename}")  # , self._testMethodName)
            try:
                os.remove(filename)
            except Exception as e:
                print(e)

    def test_appendCover_ShouldAppendOne(self):
        with zipfile.ZipFile(self.test_files_names[0], 'r') as zin:
            item_count = len(zin.namelist())

        values_to_process = cover_process_item_info(
            cbz_file=self.test_files_names[0],
            cover_path=self.sample_cover,
            cover_format="jpg"
        )
        SetCover(values_to_process)
        with zipfile.ZipFile(self.test_files_names[0], 'r') as zin:
            item_count2 = len(zin.namelist())
        print(f"Asserting new file has original files + new cover since its appended - {item_count} vs {item_count2}")
        self.assertEqual((item_count + 1), item_count2)

        print(pathlib.Path(self.test_files_names[0]))
        # print(os.path.dirname(self.test_files_names[0]))
        final_dir_count = len(os.listdir(os.path.dirname(self.test_files_names[0])))
        print(f"Asserting {self.initial_dir_count} vs {final_dir_count}")
        self.assertEqual(self.initial_dir_count, final_dir_count)

    def test_appendCover_ShouldOverwriteFirst(self):
        # Append one image named 0000.ext
        with zipfile.ZipFile(self.test_files_names[0], mode='a') as zf:
            image = Image.new('RGB', size=(20, 20), color=(255, 73, 95))
            image.format = "JPEG"
            imgByteArr = io.BytesIO()
            image.save(imgByteArr, format=image.format)
            imgByteArr = imgByteArr.getvalue()
            zf.writestr(f"0000.jpg", imgByteArr)
        # Count files in archive
        with zipfile.ZipFile(self.test_files_names[0], mode='r') as zin:
            item_count = len(zin.namelist())
        values_to_process = cover_process_item_info(
            cbz_file=self.test_files_names[0],
            cover_path=self.sample_cover,
            cover_format="jpg"
        )
        # Append cover
        SetCover(values_to_process)
        with zipfile.ZipFile(self.test_files_names[0], 'r') as zin:
            item_count2 = len(zin.namelist())
        print(
            f"Asserting new file has original files + 1. First cover should be backed up since named 0000.ext - {item_count} vs {item_count2 - 1}")
        self.assertEqual(item_count, item_count2 - 1)

        final_dir_count = len(os.listdir(os.path.dirname(self.test_files_names[0])))
        print(f"Asserting {self.initial_dir_count} vs {final_dir_count}")
        self.assertEqual(self.initial_dir_count, final_dir_count)

    def test_overwriteCover(self):
        # Count files in archive
        with zipfile.ZipFile(self.test_files_names[0], 'r') as zin:
            item_count = len(zin.namelist())
        values_to_process = cover_process_item_info(
            cbz_file=self.test_files_names[0],
            cover_path=self.sample_cover,
            cover_format="jpg",
            coverOverwrite=True
        )
        # Overwrite cover
        SetCover(values_to_process)
        with zipfile.ZipFile(self.test_files_names[0], 'r') as zin:
            item_count2 = len(zin.namelist())
        print(
            f"Asserting new file has original files. First image should be backed up- {item_count} vs {item_count2 - 1}")
        self.assertEqual(item_count, item_count2 - 1)

        final_dir_count = len(os.listdir(os.path.dirname(self.test_files_names[0])))
        print(f"Asserting {self.initial_dir_count} vs {final_dir_count}")
        self.assertEqual(self.initial_dir_count, final_dir_count)

    def test_deleteCover(self):
        # Count files in archive
        with zipfile.ZipFile(self.test_files_names[0], 'r') as zin:
            item_count = len(zin.namelist())
        values_to_process = cover_process_item_info(
            cbz_file=self.test_files_names[0],
            cover_path=self.sample_cover,
            cover_format="jpg",
            coverDelete=True,
        )
        # Delete cover
        SetCover(values_to_process)
        with zipfile.ZipFile(self.test_files_names[0], 'r') as zin:
            item_count2 = len(zin.namelist())
        print(f"Asserting new file has original files. First image should be backed up - {item_count} vs {item_count2}")
        self.assertEqual(item_count, item_count2)

        final_dir_count = len(os.listdir(os.path.dirname(self.test_files_names[0])))
        print(f"Asserting {self.initial_dir_count} vs {final_dir_count}")
        self.assertEqual(self.initial_dir_count, final_dir_count)

    def test_recoverCover(self):
        # Append OldCover_*.ext.bak
        with zipfile.ZipFile(self.test_files_names[0], mode="a") as zf:
            image = Image.new('RGB', size=(20, 20), color=(255, 73, 95))
            image.format = "JPEG"
            imgByteArr = io.BytesIO()
            image.save(imgByteArr, format=image.format)
            imgByteArr = imgByteArr.getvalue()
            zf.writestr(f"OldCover_0000.jpg.bak", imgByteArr)
        # Count files in archive
        with zipfile.ZipFile(self.test_files_names[0], 'r') as zin:
            item_count = len(zin.namelist())
        values_to_process = cover_process_item_info(
            cbz_file=self.test_files_names[0],
            cover_path=self.sample_cover,
            cover_format="jpg",
            coverRecover=True
        )
        # Delete cover
        SetCover(values_to_process)
        with zipfile.ZipFile(self.test_files_names[0], 'r') as zin:
            item_count2 = len(zin.namelist())
            print("Asserting renamed file 0000.ext is in namelist")
            print(zin.namelist())
            self.assertTrue("0000.jpg" in zin.namelist())
        print(
            f"Asserting new file has original files. OldCover should be renamed to 000.ext - {item_count} vs {item_count2}")
        self.assertEqual(item_count, item_count2)

        final_dir_count = len(os.listdir(os.path.dirname(self.test_files_names[0])))
        print(f"Asserting {self.initial_dir_count} vs {final_dir_count}")
        self.assertEqual(self.initial_dir_count, final_dir_count)


class MetadataManagerTester(unittest.TestCase):
    def setUp(self) -> None:

        self.test_files_names = []
        print("\n", self._testMethodName)
        print("Setup:")
        for ai in range(3):
            out_tmp_zipname = f"Test_{ai}_{random.randint(1, 6000)}.cbz"
            self.test_files_names.append(out_tmp_zipname)
            self.temp_folder = tempfile.mkdtemp()
            # print("", self._testMethodName)
            print(f"     Creating: {out_tmp_zipname}")  # , self._testMethodName)
            with zipfile.ZipFile(out_tmp_zipname, "w") as zf:
                for i in range(5):
                    image = Image.new('RGB', size=(20, 20), color=(255, 73, 95))
                    image.format = "JPEG"
                    # file = tempfile.NamedTemporaryFile(suffix=f'.jpg', prefix=str(i).zfill(3), dir=self.temp_folder)
                    imgByteArr = io.BytesIO()
                    image.save(imgByteArr, format=image.format)
                    imgByteArr = imgByteArr.getvalue()
                    # image.save(file, format='JPEG')
                    # file.write(image.tobytes())
                    zf.writestr(os.path.basename(f"{str(i).zfill(3)}.jpg"), imgByteArr)

            self.initial_dir_count = len(os.listdir(os.getcwd()))

    def tearDown(self) -> None:
        print("Teardown:")
        for filename in self.test_files_names:
            print(f"     Deleting: {filename}")  # , self._testMethodName)
            try:
                os.remove(filename)
            except Exception as e:
                print(e)

    def test_replace_file(self):
        """The number of files read in the output cbz must be the same as in the input (check needed to not end up
        with empty unreadable files """
        first_file_chapter = ""
        second_file_chapter = ""

        test_files = self.test_files_names
        opened_cbz = ReadComicInfo(test_files[0], ignore_empty_metadata=True)
        number_files_preprocess_1 = opened_cbz.total_files
        opened_cbz = 0  # reset so file gets closed
        opened_cbz = ReadComicInfo(test_files[1], ignore_empty_metadata=True)
        number_files_preprocess_2 = opened_cbz.total_files
        opened_cbz = 0  # reset so file gets closed

        random_int = random.random() + random.randint(1, 40)
        random_int_comRating = random.randint(0, 5)
        root = tk.Tk()
        app: MetadataManager.App = MetadataManager.App(root)
        app.create_loadedComicInfo_list(test_files)

        for widget_var in app.widgets_var:
            if str(widget_var) == "OptionMenu_BlackWhite":
                widget_var.set(ComicInfo.YesNo.YES)
            elif str(widget_var) == "OptionMenu_Manga":
                widget_var.set(ComicInfo.Manga.YES_AND_RIGHT_TO_LEFT)
            elif str(widget_var) == "OptionMenu_AgeRating":
                widget_var.set(ComicInfo.AgeRating.RATING_PENDING)
            elif str(widget_var) == "CommunityRating":
                widget_var.set(int(random_int_comRating))
            elif isinstance(widget_var, tk.StringVar):
                widget_var.set(f"This is: {str(widget_var)} modified randint:{random_int}")
            elif isinstance(widget_var, tk.IntVar):
                widget_var.set(int(random_int))
            # else:
            #     widget_var.set(random_int)
        app.input_1_summary_obj.set(f"This is the summary_{random_int}")

        # Chapter number must be kept when handling multiple files they can't be the same.

        app.do_save_UI()
        for file_counter, test_file_path in enumerate(test_files):

            opened_cbz = ReadComicInfo(test_file_path)
            number_files_postprocess = opened_cbz.total_files
            xml_postprocess = opened_cbz.to_ComicInfo()
            print(f"Asserting second file {number_files_preprocess_2} vs {number_files_postprocess}, delta 1")
            self.assertAlmostEqual(number_files_preprocess_2, number_files_postprocess, delta=1)

            print(f"Random assertion values")
            app: MetadataManager.App = MetadataManager.App(root)
            app.create_loadedComicInfo_list([test_file_path])
            # for i in range(7):
            #     with self.subTest(i=i):
            for i, widget_var in enumerate(app.widgets_var):
                with self.subTest(f"F:{file_counter} - {str(widget_var)}"):
                    if str(widget_var) == "OptionMenu_BlackWhite":
                        print("    ┣━━	Assert OptionMenu_BlackWhite")
                        # widget_var.set(ComicInfo.YesNo.YES)
                    elif str(widget_var) == "OptionMenu_Manga":
                        print("    ┣━━	Assert OptionMenu_Manga")
                        self.assertEqual(widget_var.get(), ComicInfo.Manga.YES_AND_RIGHT_TO_LEFT)
                    elif str(widget_var) == "OptionMenu_AgeRating":
                        print("    ┣━━	Assert OptionMenu_AgeRating")
                        self.assertEqual(widget_var.get(), ComicInfo.AgeRating.RATING_PENDING)
                    elif isinstance(widget_var, models.LongText):
                        print("    ┣━━	Assert LongText")
                        self.assertEqual(widget_var.get(), f"This is the summary_{random_int}")
                    elif str(widget_var) == "CommunityRating":
                        print("    ┣━━	Assert CommunityRating")
                        self.assertEqual(int(widget_var.get()), int(random_int_comRating))
                    elif isinstance(widget_var, tk.StringVar):
                        print(
                            f"    ┣━━	Assert {str(widget_var)}:\n    ┃   ┗━━ 'This is: {str(widget_var)} modified randint:{random_int}' vs '{widget_var.get()}'\n    ┃")
                        self.assertEqual(widget_var.get(), f"This is: {str(widget_var)} modified randint:{random_int}")
                    elif isinstance(widget_var, tk.IntVar):
                        print(
                            f"    ┣━━	Assert {str(widget_var)}:\n    ┃   ┗━━ '{widget_var.get()}' vs '{int(random_int)}'\n    ┃")
                        self.assertEqual(int(widget_var.get()), int(random_int))
                        # else:
                    #     self.assertEqual(widget_var.get(), random_int)

    def test_conflict(self):
        """
        Files with random values. Modified values should be applied to all files while retaining original non-modified values
        """
        random_values = []
        # Create random values for each field

        for i, test_file_path in enumerate(self.test_files_names):
            random_value = random.random() + random.randint(1, 40)
            root = tk.Tk()
            app: MetadataManager.App = MetadataManager.App(root)
            app.create_loadedComicInfo_list([test_file_path])

            for widget_var in app.widgets_var:
                if str(widget_var) == "OptionMenu_BlackWhite":
                    widget_var.set(ComicInfo.YesNo.YES)
                elif str(widget_var) == "OptionMenu_Manga":
                    widget_var.set(ComicInfo.Manga.YES_AND_RIGHT_TO_LEFT)
                elif str(widget_var) == "OptionMenu_AgeRating":
                    widget_var.set(ComicInfo.AgeRating.RATING_PENDING)
                elif isinstance(widget_var, models.LongText):
                    widget_var.set(f"This is the summary_{random_value}")
                elif str(widget_var) == "CommunityRating":
                    widget_var.set(int(random_value))
                elif isinstance(widget_var, tk.StringVar):
                    widget_var.set(f"This is: {str(widget_var)} modified randint:{random_value}")
                elif isinstance(widget_var, tk.IntVar):
                    widget_var.set(int(random_value))
            app.do_save_UI()

            random_values.append(random_value)

        # Load all files at once

        modified_value = random.random() + random.randint(1, 40)
        root = tk.Tk()
        app: MetadataManager.App = MetadataManager.App(root)
        app.create_loadedComicInfo_list(self.test_files_names)

        app.entry_Volume_val.set(int(modified_value))
        app.entry_Series_val.set(f"This is: {str(app.entry_Series_val)} modified randint:{modified_value}")
        app.entry_Count_val.set(int(modified_value))
        app.do_save_UI()

        for i, test_file_path in enumerate(self.test_files_names):
            print("Asserting second file 5 vs 6, delta 2")
            self.assertAlmostEqual(5, 6, delta=1)
            print(f"Random assertion values")
            self.assertTrue(True)
            root = tk.Tk()
            app: MetadataManager.App = MetadataManager.App(root)
            app.create_loadedComicInfo_list([test_file_path])
            random_value = random_values[i]
            print(
                f"\n┃ #####\n┃ ##### Starting subtests\n┃ #####\n┃ Random values:{random_values[-1]}\n┃ Current file: {i}\n┕━━━┓")
            for widget_var in app.widgets_var:
                with self.subTest(f"Subtest - File:{i} - {str(widget_var)}"):
                    if str(widget_var) == "Volume" or str(widget_var) == "Count":
                        print(
                            f"    ┣━━	Assert MODIFIED {str(widget_var)}:\n    ┃   ┗━━ 'This is: '{widget_var.get()}' vs '{int(modified_value)}'\n    ┃")
                        self.assertEqual(int(widget_var.get()), int(modified_value))
                    elif str(widget_var) == "Series":
                        print(
                            f"    ┣━━	Assert MODIFIED {str(widget_var)}:\n    ┃   ┗━━ 'This is: {str(widget_var)} modified randint:{modified_value}' vs '{widget_var.get()}'\n    ┃")
                        self.assertEqual(widget_var.get(),
                                         f"This is: {str(widget_var)} modified randint:{modified_value}")
                    elif str(widget_var) == "OptionMenu_BlackWhite":
                        print("    ┣━━	Assert OptionMenu_BlackWhite")
                    elif str(widget_var) == "OptionMenu_Manga":
                        print("    ┣━━	Assert OptionMenu_Manga")
                        self.assertEqual(widget_var.get(), ComicInfo.Manga.YES_AND_RIGHT_TO_LEFT)
                    elif str(widget_var) == "OptionMenu_AgeRating":
                        print("    ┣━━	Assert OptionMenu_AgeRating")
                        self.assertEqual(widget_var.get(), ComicInfo.AgeRating.RATING_PENDING)
                    elif isinstance(widget_var, models.LongText):
                        print("    ┣━━	Assert LongText")
                        self.assertEqual(f"This is the summary_{random_value}", widget_var.get())
                    elif str(widget_var) == "CommunityRating":
                        print("    ┣━━	Assert CommunityRating")
                        self.assertEqual(int(widget_var.get()), int(random_value))
                    elif isinstance(widget_var, tk.StringVar):
                        print(
                            f"    ┣━━	Assert {str(widget_var)}:\n    ┃   ┗━━ 'This is: {str(widget_var)} modified randint:{random_value}' vs '{widget_var.get()}'\n    ┃")
                        self.assertEqual(f"This is: {str(widget_var)} modified randint:{random_value}",
                                         widget_var.get())
                    elif isinstance(widget_var, tk.IntVar):
                        print(
                            f"    ┣━━	Assert {str(widget_var)}:\n    ┃   ┗━━ '{widget_var.get()}' vs '{int(random_value)}'\n    ┃")
                        self.assertEqual(widget_var.get(), int(random_value))


class VolumeManagerTester(unittest.TestCase):
    def setUp(self) -> None:
        self.test_files_names = []  # Simulated list of filepaths
        print("\n", self._testMethodName)
        print("Setup:")
        image = Image.new('RGB', size=(20, 20), color=(255, 73, 95))
        image.format = "JPEG"
        imgByteArr = io.BytesIO()
        image.save(imgByteArr, format=image.format)
        imgByteArr = imgByteArr.getvalue()
        for ai in range(1, 7):  # Create 7 archives.cbz
            out_tmp_zipname = f"Test_{ai}_{random.randint(1, 6000)} Ch.{ai}.cbz"
            self.test_files_names.append(os.path.abspath(out_tmp_zipname))
            self.temp_folder = tempfile.mkdtemp()
            print(f"     Creating: {out_tmp_zipname}")  # , self._testMethodName)
            with zipfile.ZipFile(out_tmp_zipname, "w") as zf:
                for i in range(1, 6):
                    zf.writestr(f"{str(i).zfill(3)}.jpg", imgByteArr)
        self.initial_dir_count = len(os.listdir(os.getcwd()))

    def tearDown(self) -> None:
        print("Teardown:")
        for filename in self.test_files_names:
            print(f"     Deleting: {filename}")  # , self._testMethodName)
            try:
                os.remove(filename)
            except Exception as e:
                print(e)

    def test_rename(self):

        test_path = self.test_files_names[0]

        random_vol_number = random.randint(1, 500)
        test_path_dir = os.path.dirname(test_path)
        file_regex_finds = VolumeManager.parse_fileName(test_path, random_vol_number)
        new_file_path = os.path.dirname(test_path)
        new_fileName_toAssert = str(pathlib.Path(new_file_path,
                                                 f"{file_regex_finds.name} Vol.{random_vol_number} {file_regex_finds.chapterinfo}{file_regex_finds.afterchapter}".replace(
                                                     "  ", " ")))

        with zipfile.ZipFile(self.test_files_names[0], 'r') as zin:
            initial_dir_count = len(zin.namelist())
        root = tk.Tk()
        app = VolumeManager.App(root)
        app.cli_set_volume(random_vol_number)
        app.cli_select_files([test_path])
        self.test_files_names[0] = new_fileName_toAssert
        # app.checkbutton_4_settings_val.set(True)  # Enables saving to comicinfo
        app.process()
        print(f"Asserting if renamed file exists in directory ({os.path.basename(new_fileName_toAssert)} in Folder)")
        items_in_test_path_dir = os.listdir(test_path_dir)
        self.assertTrue(os.path.basename(new_fileName_toAssert) in items_in_test_path_dir)

    # @unittest.SkipTest
    def test_addVolume_toComicInfo(self):

        test_path = self.test_files_names[0]
        with zipfile.ZipFile(test_path, 'r') as zin:
            initial_dir_count = len(zin.namelist())
        random_vol_number = random.randint(1, 500)
        test_path_dir = os.path.dirname(test_path)
        new_file_path = os.path.dirname(test_path)
        with zipfile.ZipFile(test_path, 'r') as zin:
            initial_dir_count = len(zin.namelist())
        root = tk.Tk()
        app = VolumeManager.App(root)
        app.checkbutton_4_5_settings_val.set(True)  # Do not rename the file
        app.checkbutton_4_settings_val.set(True)  # Enables saving to comicinfo
        app.cli_set_volume(random_vol_number)
        app.cli_select_files([test_path])
        app.process()

        app = ReadComicInfo(test_path, ignore_empty_metadata=False).to_ComicInfo()

        with zipfile.ZipFile(test_path, 'r') as zin:
            final_dir_count = len(zin.namelist())

        print(f"Asserting if new volume number in comicinfo is saved ({random_vol_number}=={app.get_Volume()})")
        self.assertEqual(random_vol_number, app.get_Volume())

        # final_dir_count = len(os.listdir(os.path.dirname(test_path)))
        print(f"Asserting leftover files {initial_dir_count} vs {final_dir_count}")
        self.assertEqual(initial_dir_count, (final_dir_count - 1))

    def test_addVolume_and_rename(self):

        test_path = self.test_files_names[0]

        random_vol_number = random.randint(1, 500)
        test_path_dir = os.path.dirname(test_path)
        file_regex_finds = VolumeManager.parse_fileName(test_path, random_vol_number)
        new_file_path = os.path.dirname(test_path)
        new_fileName_toAssert = str(pathlib.Path(new_file_path,
                                                 f"{file_regex_finds.name} Vol.{random_vol_number} {file_regex_finds.chapterinfo}{file_regex_finds.afterchapter}".replace(
                                                     "  ", " ")))

        with zipfile.ZipFile(self.test_files_names[0], 'r') as zin:
            initial_dir_count = len(zin.namelist())
        root = tk.Tk()
        app = VolumeManager.App(root)
        app.cli_set_volume(random_vol_number)
        app.cli_select_files([test_path])
        self.test_files_names[0] = new_fileName_toAssert
        app.checkbutton_4_settings_val.set(True)  # Enables saving to comicinfo
        app.process()
        print(f"Asserting if renamed file exists in directory ({os.path.basename(new_fileName_toAssert)} in Folder)")
        items_in_test_path_dir = os.listdir(test_path_dir)
        self.assertTrue(os.path.basename(new_fileName_toAssert) in items_in_test_path_dir)

        app = ReadComicInfo(new_fileName_toAssert, ignore_empty_metadata=False).to_ComicInfo()
        print(f"Asserting if new volume number in comicinfo is saved ({random_vol_number}=={app.get_Volume()})")
        self.assertEqual(random_vol_number, app.get_Volume())
        with zipfile.ZipFile(new_fileName_toAssert, 'r') as zin:
            final_dir_count = len(zin.namelist())
        # final_dir_count = len(os.listdir(os.path.dirname(test_path)))
        print(f"Asserting leftover files {initial_dir_count} vs {final_dir_count}")
        self.assertEqual(initial_dir_count, (final_dir_count - 1))


#
#
# class Epub2CbzTester(unittest.TestCase):
#     # TODO: This unit test needs to be rewritten. It's too messy
#     def setUp(self) -> None:
#         self.newEpubFileName = "TestEpub.epub"
#         self.newEpubFilePath = rf"{os.getcwd()}/{self.newEpubFileName}"
#         self.generatedImagesNumber = random.randint(1, 15)
#         with ZipFile(self.newEpubFilePath, "w") as zout:
#             for newFile_number in range(self.generatedImagesNumber):
#                 new_name = f"{newFile_number}".zfill(3)
#                 zout.write(sample_cover, f"images/{new_name}.jpg")
#
#         self.root = tk.Tk()
#
#     def test_convert(self):
#         app = epub2cbz.App(self.root, [self.newEpubFilePath])
#         app.output_folder = os.getcwd()
#
#         newCbzPath = (os.getcwd() + "/" + self.newEpubFileName).replace(
#             re.findall(r"(?i).*(\.[a-z]+$)", self.newEpubFilePath)[0]
#             , ".cbz")
#         app.start()
#         app = None
#         try:
#             with ZipFile(newCbzPath, 'r') as zipCbz:
#                 print("")
#                 print(
#                     f"Assert number of files in epub/images == files in cbz -> {len(zipCbz.namelist())}=={self.generatedImagesNumber}")
#                 self.assertEqual(len(zipCbz.namelist()), self.generatedImagesNumber)
#         except AssertionError as e:
#             os.remove(self.newEpubFilePath)
#             os.remove(newCbzPath)
#             raise e
#         except PermissionError as e:
#             print("Can't delete the files")
#             raise e
#
#         try:
#             os.remove(self.newEpubFilePath)
#             os.remove(newCbzPath)
#         except Exception as e:
#             pass
#

if __name__ == '__main__':
    unittest.main()
