# common
import pathlib
import random
import tkinter as tk
import unittest

# Epub2Cbz
from PIL import Image

from CoverManagerLib.cbz_handler import SetCover
from CoverManagerLib.models import cover_process_item_info
# Volume Manager
from MangaManager.VolumeManager import VolumeManager
from MetadataManagerLib import MetadataManager, models
from MetadataManagerLib.cbz_handler import *

# Manga Tagger
# Cover Manager
comicinfo_23 = """
<ComicInfo xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
   <!--Generated by Manga Tagger, an Endless Galaxy Studios project-->
   <Series>Maou ni Natta node, Dungeon Tsukutte Jingai Musume to Honobono suru</Series>
   <Number>23</Number>
   <Count>1</Count>
   <Summary/>
   <Year>2018</Year>
   <Month>5</Month>
   <Writer>Ryuuyuu</Writer>
   <Penciller>Note Toono</Penciller>
   <Inker>Note Toono</Inker>
   <Colorist>Note Toono</Colorist>
   <Letterer>Note Toono</Letterer>
   <CoverArtist>Note Toono</CoverArtist>
   <Publisher>Dra-Dra-Dragon Age</Publisher>
   <Genre>Fantasy</Genre>
   <Web>https://myanimelist.net/manga/115200/Maou_ni_Natta_node_Dungeon_Tsukutte_Jingai_Musume_to_Honobono_suru</Web>
   <LanguageISO>en</LanguageISO>
   <Manga>Yes</Manga>
   <Notes>Scraped metadata from AniList and MyAnimeList (using Jikan API) on 2021-12-24 12:38 PM EST</Notes>
</ComicInfo>
"""
comicinfo_24 = """
<ComicInfo xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
   <!--Generated by Manga Tagger, an Endless Galaxy Studios project-->
   <Series>Maou ni Natta node, Dungeon Tsukutte Jingai Musume to Honobono suru</Series>
   <Number>24</Number>
   <Count>1</Count>
   <Summary/>
   <Year>2018</Year>
   <Month>5</Month>
   <Writer>Ryuuyuu</Writer>
   <Penciller>Note Toono</Penciller>
   <Inker>Note Toono</Inker>
   <Colorist>Note Toono</Colorist>
   <Letterer>Note Toono</Letterer>
   <CoverArtist>Note Toono</CoverArtist>
   <Publisher>Dra-Dra-Dragon Age</Publisher>
   <Genre>Fantasy</Genre>
   <Web>https://myanimelist.net/manga/115200/Maou_ni_Natta_node_Dungeon_Tsukutte_Jingai_Musume_to_Honobono_suru</Web>
   <LanguageISO>en</LanguageISO>
   <Manga>Yes</Manga>
   <Notes>Scraped metadata from AniList and MyAnimeList (using Jikan API) on 2021-12-24 12:38 PM EST</Notes>
</ComicInfo>
"""

original_cleanup_var1 = ""
final_cleanup_var1 = ""


class ComicInfoClassTester(unittest.TestCase):
    """
    The purpose of this test is to check ComicInfo class is properly edited.
    ComicInfo is an automatically generated class with some change.
    """

    def setUp(self) -> None:
        self.comicinfo = ComicInfo.ComicInfo()
        self.comicinfo.set_AgeRating(ComicInfo.AgeRating.RATING_PENDING)

    def test_manualModifications(self):
        # @classmethod
        # def list(cls):
        #     return list(map(lambda c: c.value, cls))
        self.assertTrue(ComicInfo.AgeRating.list())
        self.assertTrue(ComicInfo.ComicPageType.list())
        ComicInfo.parseString(comicinfo_23, silence=True, print_warnings=False, doRecover=True)


class CoverManagerTester(unittest.TestCase):
    """
    This test checks the functionality of coverManager and makes sure that the content of the files do not get wiped
    """

    def setUp(self) -> None:
        self.test_files_names = []  # Simulated list of filepaths
        print("\n", self._testMethodName)
        print("Setup:")
        image = Image.new('RGB', size=(20, 20), color=(255, 73, 95))
        image.format = "JPEG"
        imgByteArr = io.BytesIO()
        image.save(imgByteArr, format=image.format)
        imgByteArr = imgByteArr.getvalue()
        for ai in range(3):  # Create 3 archives.cbz
            out_tmp_zipname = f"Test_{ai}_{random.randint(1, 6000)}.cbz"
            self.test_files_names.append(os.path.abspath(out_tmp_zipname))
            self.temp_folder = tempfile.mkdtemp()
            print(f"     Creating: {out_tmp_zipname}")  # , self._testMethodName)
            with zipfile.ZipFile(out_tmp_zipname, "w") as zf:
                for i in range(1, 6):
                    zf.writestr(f"{str(i).zfill(3)}.jpg", imgByteArr)
        image.save("Test_4_sample_cover.jpg", format=image.format)
        self.test_files_names.append(os.path.abspath("Test_4_sample_cover.jpg"))
        self.sample_cover = os.path.abspath("Test_4_sample_cover.jpg")
        self.initial_dir_count = len(os.listdir(os.getcwd()))

    def tearDown(self) -> None:
        print("Teardown:")
        for filename in self.test_files_names:
            print(f"     Deleting: {filename}")  # , self._testMethodName)
            try:
                os.remove(filename)
            except Exception as e:
                print(e)

    def test_appendCover_ShouldAppendOne(self):
        with zipfile.ZipFile(self.test_files_names[0], 'r') as zin:
            item_count = len(zin.namelist())

        values_to_process = cover_process_item_info(
            cbz_file=self.test_files_names[0],
            cover_path=self.sample_cover,
            cover_format="jpg"
        )
        SetCover(values_to_process)
        with zipfile.ZipFile(self.test_files_names[0], 'r') as zin:
            item_count2 = len(zin.namelist())
        print(f"Asserting new file has original files + new cover since its appended - {item_count} vs {item_count2}")
        self.assertEqual((item_count + 1), item_count2)

        print(pathlib.Path(self.test_files_names[0]))
        # print(os.path.dirname(self.test_files_names[0]))
        final_dir_count = len(os.listdir(os.path.dirname(self.test_files_names[0])))
        print(f"Asserting {self.initial_dir_count} vs {final_dir_count}")
        self.assertEqual(self.initial_dir_count, final_dir_count)

    def test_appendCover_ShouldOverwriteFirst(self):
        # Append one image named 0000.ext
        with zipfile.ZipFile(self.test_files_names[0], mode='a') as zf:
            image = Image.new('RGB', size=(20, 20), color=(255, 73, 95))
            image.format = "JPEG"
            imgByteArr = io.BytesIO()
            image.save(imgByteArr, format=image.format)
            imgByteArr = imgByteArr.getvalue()
            zf.writestr(f"0000.jpg", imgByteArr)
        # Count files in archive
        with zipfile.ZipFile(self.test_files_names[0], mode='r') as zin:
            item_count = len(zin.namelist())
        values_to_process = cover_process_item_info(
            cbz_file=self.test_files_names[0],
            cover_path=self.sample_cover,
            cover_format="jpg"
        )
        # Append cover
        SetCover(values_to_process)
        with zipfile.ZipFile(self.test_files_names[0], 'r') as zin:
            item_count2 = len(zin.namelist())
        print(
            f"Asserting new file has original files + 1. First cover should be backed up since named 0000.ext - {item_count} vs {item_count2 - 1}")
        self.assertEqual(item_count, item_count2 - 1)

        final_dir_count = len(os.listdir(os.path.dirname(self.test_files_names[0])))
        print(f"Asserting {self.initial_dir_count} vs {final_dir_count}")
        self.assertEqual(self.initial_dir_count, final_dir_count)

    def test_overwriteCover(self):
        # Count files in archive
        with zipfile.ZipFile(self.test_files_names[0], 'r') as zin:
            item_count = len(zin.namelist())
        values_to_process = cover_process_item_info(
            cbz_file=self.test_files_names[0],
            cover_path=self.sample_cover,
            cover_format="jpg",
            coverOverwrite=True
        )
        # Overwrite cover
        SetCover(values_to_process)
        with zipfile.ZipFile(self.test_files_names[0], 'r') as zin:
            item_count2 = len(zin.namelist())
        print(
            f"Asserting new file has original files. First image should be backed up- {item_count} vs {item_count2 - 1}")
        self.assertEqual(item_count, item_count2 - 1)

        final_dir_count = len(os.listdir(os.path.dirname(self.test_files_names[0])))
        print(f"Asserting {self.initial_dir_count} vs {final_dir_count}")
        self.assertEqual(self.initial_dir_count, final_dir_count)

    def test_deleteCover(self):
        # Count files in archive
        with zipfile.ZipFile(self.test_files_names[0], 'r') as zin:
            item_count = len(zin.namelist())
        values_to_process = cover_process_item_info(
            cbz_file=self.test_files_names[0],
            cover_path=self.sample_cover,
            cover_format="jpg",
            coverDelete=True,
        )
        # Delete cover
        SetCover(values_to_process)
        with zipfile.ZipFile(self.test_files_names[0], 'r') as zin:
            item_count2 = len(zin.namelist())
        print(f"Asserting new file has original files. First image should be backed up - {item_count} vs {item_count2}")
        self.assertEqual(item_count, item_count2)

        final_dir_count = len(os.listdir(os.path.dirname(self.test_files_names[0])))
        print(f"Asserting {self.initial_dir_count} vs {final_dir_count}")
        self.assertEqual(self.initial_dir_count, final_dir_count)

    def test_recoverCover(self):
        # Append OldCover_*.ext.bak
        with zipfile.ZipFile(self.test_files_names[0], mode="a") as zf:
            image = Image.new('RGB', size=(20, 20), color=(255, 73, 95))
            image.format = "JPEG"
            imgByteArr = io.BytesIO()
            image.save(imgByteArr, format=image.format)
            imgByteArr = imgByteArr.getvalue()
            zf.writestr(f"OldCover_0000.jpg.bak", imgByteArr)
        # Count files in archive
        with zipfile.ZipFile(self.test_files_names[0], 'r') as zin:
            item_count = len(zin.namelist())
        values_to_process = cover_process_item_info(
            cbz_file=self.test_files_names[0],
            cover_path=self.sample_cover,
            cover_format="jpg",
            coverRecover=True
        )
        # Delete cover
        SetCover(values_to_process)
        with zipfile.ZipFile(self.test_files_names[0], 'r') as zin:
            item_count2 = len(zin.namelist())
            print("Asserting renamed file 0000.ext is in namelist")
            print(zin.namelist())
            self.assertTrue("0000.jpg" in zin.namelist())
        print(
            f"Asserting new file has original files. OldCover should be renamed to 000.ext - {item_count} vs {item_count2}")
        self.assertEqual(item_count, item_count2)

        final_dir_count = len(os.listdir(os.path.dirname(self.test_files_names[0])))
        print(f"Asserting {self.initial_dir_count} vs {final_dir_count}")
        self.assertEqual(self.initial_dir_count, final_dir_count)


class MetadataManagerTester(unittest.TestCase):
    def setUp(self) -> None:

        self.test_files_names = []
        print("\n", self._testMethodName)
        print("Setup:")
        for ai in range(3):
            out_tmp_zipname = f"Test_{ai}_{random.randint(1, 6000)}.cbz"
            self.test_files_names.append(out_tmp_zipname)
            self.temp_folder = tempfile.mkdtemp()
            # print("", self._testMethodName)
            print(f"     Creating: {out_tmp_zipname}")  # , self._testMethodName)
            with zipfile.ZipFile(out_tmp_zipname, "w") as zf:
                for i in range(5):
                    image = Image.new('RGB', size=(20, 20), color=(255, 73, 95))
                    image.format = "JPEG"
                    # file = tempfile.NamedTemporaryFile(suffix=f'.jpg', prefix=str(i).zfill(3), dir=self.temp_folder)
                    imgByteArr = io.BytesIO()
                    image.save(imgByteArr, format=image.format)
                    imgByteArr = imgByteArr.getvalue()
                    # image.save(file, format='JPEG')
                    # file.write(image.tobytes())
                    zf.writestr(os.path.basename(f"{str(i).zfill(3)}.jpg"), imgByteArr)

            self.initial_dir_count = len(os.listdir(os.getcwd()))

    def tearDown(self) -> None:
        print("Teardown:")
        for filename in self.test_files_names:
            print(f"     Deleting: {filename}")  # , self._testMethodName)
            try:
                os.remove(filename)
            except Exception as e:
                print(e)

    def test_replace_file(self):
        """The number of files read in the output cbz must be the same as in the input (check needed to not end up
        with empty unreadable files """
        import tkinter as tk
        first_file_chapter = ""
        second_file_chapter = ""

        test_files = self.test_files_names
        opened_cbz = ReadComicInfo(test_files[0], ignore_empty_metadata=True)
        number_files_preprocess_1 = opened_cbz.total_files
        opened_cbz = 0  # reset so file gets closed
        opened_cbz = ReadComicInfo(test_files[1], ignore_empty_metadata=True)
        number_files_preprocess_2 = opened_cbz.total_files
        opened_cbz = 0  # reset so file gets closed

        random_int = random.random()
        root = tk.Tk()
        app: MetadataManager.App = MetadataManager.App(root)
        app.create_loadedComicInfo_list(test_files)

        for widget_var in app.widgets_var:
            if str(widget_var) == "OptionMenu_BlackWhite":
                widget_var.set(ComicInfo.YesNo.YES)
            elif str(widget_var) == "OptionMenu_Manga":
                widget_var.set(ComicInfo.Manga.YES_AND_RIGHT_TO_LEFT)
            elif str(widget_var) == "OptionMenu_AgeRating":
                widget_var.set(ComicInfo.AgeRating.RATING_PENDING)
            elif str(widget_var) == "CommunityRating":
                widget_var.set(int(random_int))
            elif isinstance(widget_var, tk.StringVar):
                widget_var.set(f"This is: {str(widget_var)} modified randint:{random_int}")

            # else:
            #     widget_var.set(random_int)
        app.input_1_summary_obj.set(f"This is the summary_{random_int}")

        # Chapter number must be kept when handling multiple files they can't be the same.

        app.do_save_UI()

        opened_cbz = ReadComicInfo(test_files[0])
        number_files_postprocess = opened_cbz.total_files
        xml_postprocess = opened_cbz.to_ComicInfo()
        if not first_file_chapter:
            first_file_chapter = xml_postprocess.get_Number()

        # self.assertAlmostEqual(number_files_preprocess, number_files_postprocess)
        print(f"Asserting first file {number_files_preprocess_1} vs {number_files_postprocess}, delta 1")
        self.assertAlmostEqual(number_files_preprocess_1, number_files_postprocess, delta=1)

        opened_cbz = ReadComicInfo(test_files[1])
        number_files_postprocess = opened_cbz.total_files
        xml_postprocess = opened_cbz.to_ComicInfo()
        print(f"Asserting second file {number_files_preprocess_2} vs {number_files_postprocess}, delta 1")
        self.assertAlmostEqual(number_files_preprocess_2, number_files_postprocess, delta=1)

        print(f"Random assertion values")
        app: MetadataManager.App = MetadataManager.App(root)
        app.create_loadedComicInfo_list(test_files)
        for i in range(7):
            with self.subTest(i=i):
                widget_var = app.widgets_var[random.randint(0, len(app.widgets_var))]
                if str(widget_var) == "OptionMenu_BlackWhite":
                    widget_var.set(ComicInfo.YesNo.YES)
                elif str(widget_var) == "OptionMenu_Manga":
                    self.assertEqual(widget_var.get(), ComicInfo.Manga.YES_AND_RIGHT_TO_LEFT)
                elif str(widget_var) == "OptionMenu_AgeRating":
                    self.assertEqual(widget_var.get(), ComicInfo.AgeRating.RATING_PENDING)
                elif isinstance(widget_var, models.LongText):
                    self.assertEqual(widget_var.get(), f"This is the summary_{random_int}")
                elif str(widget_var) == "CommunityRating":
                    self.assertEqual(int(widget_var.get()), int(random_int))
                elif isinstance(widget_var, tk.StringVar):
                    self.assertEqual(widget_var.get(), f"This is: {str(widget_var)} modified randint:{random_int}")

                # else:
                #     self.assertEqual(widget_var.get(), random_int)


class VolumeManagerTester(unittest.TestCase):
    def setUp(self) -> None:
        self.test_files_names = []  # Simulated list of filepaths
        print("\n", self._testMethodName)
        print("Setup:")
        image = Image.new('RGB', size=(20, 20), color=(255, 73, 95))
        image.format = "JPEG"
        imgByteArr = io.BytesIO()
        image.save(imgByteArr, format=image.format)
        imgByteArr = imgByteArr.getvalue()
        for ai in range(1, 7):  # Create 7 archives.cbz
            out_tmp_zipname = f"Test_{ai}_{random.randint(1, 6000)} Ch.{ai}.cbz"
            self.test_files_names.append(os.path.abspath(out_tmp_zipname))
            self.temp_folder = tempfile.mkdtemp()
            print(f"     Creating: {out_tmp_zipname}")  # , self._testMethodName)
            with zipfile.ZipFile(out_tmp_zipname, "w") as zf:
                for i in range(1, 6):
                    zf.writestr(f"{str(i).zfill(3)}.jpg", imgByteArr)
        self.initial_dir_count = len(os.listdir(os.getcwd()))

    def tearDown(self) -> None:
        print("Teardown:")
        for filename in self.test_files_names:
            print(f"     Deleting: {filename}")  # , self._testMethodName)
            try:
                os.remove(filename)
            except Exception as e:
                print(e)

    def test_rename(self):

        test_path = self.test_files_names[0]

        random_vol_number = random.randint(1, 500)
        test_path_dir = os.path.dirname(test_path)
        file_regex_finds = VolumeManager.parse_fileName(test_path, random_vol_number)
        new_file_path = os.path.dirname(test_path)
        new_fileName_toAssert = str(pathlib.Path(new_file_path,
                                                 f"{file_regex_finds.name} Vol.{random_vol_number} {file_regex_finds.chapterinfo}{file_regex_finds.afterchapter}".replace(
                                                     "  ", " ")))

        with zipfile.ZipFile(self.test_files_names[0], 'r') as zin:
            initial_dir_count = len(zin.namelist())
        root = tk.Tk()
        app = VolumeManager.App(root)
        app.cli_set_volume(random_vol_number)
        app.cli_select_files([test_path])
        self.test_files_names[0] = new_fileName_toAssert
        # app.checkbutton_4_settings_val.set(True)  # Enables saving to comicinfo
        app.process()
        print(f"Asserting if renamed file exists in directory ({os.path.basename(new_fileName_toAssert)} in Folder)")
        items_in_test_path_dir = os.listdir(test_path_dir)
        self.assertTrue(os.path.basename(new_fileName_toAssert) in items_in_test_path_dir)

    # @unittest.SkipTest
    def test_addVolume_toComicInfo(self):

        test_path = self.test_files_names[0]
        with zipfile.ZipFile(test_path, 'r') as zin:
            initial_dir_count = len(zin.namelist())
        random_vol_number = random.randint(1, 500)
        test_path_dir = os.path.dirname(test_path)
        new_file_path = os.path.dirname(test_path)
        with zipfile.ZipFile(test_path, 'r') as zin:
            initial_dir_count = len(zin.namelist())
        root = tk.Tk()
        app = VolumeManager.App(root)
        app.checkbutton_4_5_settings_val.set(True)  # Do not rename the file
        app.checkbutton_4_settings_val.set(True)  # Enables saving to comicinfo
        app.cli_set_volume(random_vol_number)
        app.cli_select_files([test_path])
        app.process()

        app = ReadComicInfo(test_path, ignore_empty_metadata=False).to_ComicInfo()

        with zipfile.ZipFile(test_path, 'r') as zin:
            final_dir_count = len(zin.namelist())

        print(f"Asserting if new volume number in comicinfo is saved ({random_vol_number}=={app.get_Volume()})")
        self.assertEqual(random_vol_number, app.get_Volume())

        # final_dir_count = len(os.listdir(os.path.dirname(test_path)))
        print(f"Asserting leftover files {initial_dir_count} vs {final_dir_count}")
        self.assertEqual(initial_dir_count, (final_dir_count - 1))

    def test_addVolume_and_rename(self):

        test_path = self.test_files_names[0]

        random_vol_number = random.randint(1, 500)
        test_path_dir = os.path.dirname(test_path)
        file_regex_finds = VolumeManager.parse_fileName(test_path, random_vol_number)
        new_file_path = os.path.dirname(test_path)
        new_fileName_toAssert = str(pathlib.Path(new_file_path,
                                                 f"{file_regex_finds.name} Vol.{random_vol_number} {file_regex_finds.chapterinfo}{file_regex_finds.afterchapter}".replace(
                                                     "  ", " ")))

        with zipfile.ZipFile(self.test_files_names[0], 'r') as zin:
            initial_dir_count = len(zin.namelist())
        root = tk.Tk()
        app = VolumeManager.App(root)
        app.cli_set_volume(random_vol_number)
        app.cli_select_files([test_path])
        self.test_files_names[0] = new_fileName_toAssert
        app.checkbutton_4_settings_val.set(True)  # Enables saving to comicinfo
        app.process()
        print(f"Asserting if renamed file exists in directory ({os.path.basename(new_fileName_toAssert)} in Folder)")
        items_in_test_path_dir = os.listdir(test_path_dir)
        self.assertTrue(os.path.basename(new_fileName_toAssert) in items_in_test_path_dir)

        app = ReadComicInfo(new_fileName_toAssert, ignore_empty_metadata=False).to_ComicInfo()
        print(f"Asserting if new volume number in comicinfo is saved ({random_vol_number}=={app.get_Volume()})")
        self.assertEqual(random_vol_number, app.get_Volume())
        with zipfile.ZipFile(new_fileName_toAssert, 'r') as zin:
            final_dir_count = len(zin.namelist())
        # final_dir_count = len(os.listdir(os.path.dirname(test_path)))
        print(f"Asserting leftover files {initial_dir_count} vs {final_dir_count}")
        self.assertEqual(initial_dir_count, (final_dir_count - 1))


#
#
# class Epub2CbzTester(unittest.TestCase):
#     # TODO: This unit test needs to be rewritten. It's too messy
#     def setUp(self) -> None:
#         self.newEpubFileName = "TestEpub.epub"
#         self.newEpubFilePath = rf"{os.getcwd()}/{self.newEpubFileName}"
#         self.generatedImagesNumber = random.randint(1, 15)
#         with ZipFile(self.newEpubFilePath, "w") as zout:
#             for newFile_number in range(self.generatedImagesNumber):
#                 new_name = f"{newFile_number}".zfill(3)
#                 zout.write(sample_cover, f"images/{new_name}.jpg")
#
#         self.root = tk.Tk()
#
#     def test_convert(self):
#         app = epub2cbz.App(self.root, [self.newEpubFilePath])
#         app.output_folder = os.getcwd()
#
#         newCbzPath = (os.getcwd() + "/" + self.newEpubFileName).replace(
#             re.findall(r"(?i).*(\.[a-z]+$)", self.newEpubFilePath)[0]
#             , ".cbz")
#         app.start()
#         app = None
#         try:
#             with ZipFile(newCbzPath, 'r') as zipCbz:
#                 print("")
#                 print(
#                     f"Assert number of files in epub/images == files in cbz -> {len(zipCbz.namelist())}=={self.generatedImagesNumber}")
#                 self.assertEqual(len(zipCbz.namelist()), self.generatedImagesNumber)
#         except AssertionError as e:
#             os.remove(self.newEpubFilePath)
#             os.remove(newCbzPath)
#             raise e
#         except PermissionError as e:
#             print("Can't delete the files")
#             raise e
#
#         try:
#             os.remove(self.newEpubFilePath)
#             os.remove(newCbzPath)
#         except Exception as e:
#             pass
#

if __name__ == '__main__':
    unittest.main()
